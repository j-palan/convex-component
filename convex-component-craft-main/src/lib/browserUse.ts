/**
 * Browser Use Component - Client Library
 * 
 * Provides a clean API for interacting with the Browser Use component
 * from your Convex app.
 */

import type { GenericActionCtx, GenericDataModel } from "convex/server";
import { z } from "zod";

// Re-export zod for schema definitions
export { z };

/**
 * Component API type - this would be generated by Convex
 * For now, we define the expected shape
 */
export interface BrowserUseComponentApi {
  lib: {
    startSession: any;
    endSession: any;
    extract: any;
    act: any;
    observe: any;
    agent: any;
    listSessions: any;
    listTasks: any;
    getLogs: any;
    getSession: any;
  };
}

/**
 * Session information returned from startSession
 */
export interface SessionInfo {
  sessionId: string;
  browserbaseSessionId?: string;
  cdpUrl?: string;
}

/**
 * Options for starting a session
 */
export interface StartSessionOptions {
  timeout?: number;
  waitUntil?: "load" | "domcontentloaded" | "networkidle";
  viewport?: { width: number; height: number };
  userAgent?: string;
}

/**
 * Action result from act()
 */
export interface ActionResult {
  success: boolean;
  message: string;
  actionDescription: string;
}

/**
 * Observable element from observe()
 */
export interface ObservableElement {
  description: string;
  selector: string;
  method: string;
  arguments?: string[];
}

/**
 * Agent action step
 */
export interface AgentAction {
  type: string;
  action?: string;
  reasoning?: string;
  timeMs?: number;
}

/**
 * Agent result from agent()
 */
export interface AgentResult {
  actions: AgentAction[];
  completed: boolean;
  message: string;
  success: boolean;
}

/**
 * Configuration for the BrowserUse client.
 * All API keys are optional: if omitted, the component uses environment variables
 * from the Convex Dashboard (Settings → Environment Variables). Prefer that for security.
 */
export interface BrowserUseConfig {
  browserbaseApiKey?: string;
  browserbaseProjectId?: string;
  modelApiKey?: string;
  modelName?: string;
}

type ActionCtx = GenericActionCtx<GenericDataModel>;

/** Build optional key args for component calls (omit when using Convex env). */
function apiKeyArgs(config: BrowserUseConfig) {
  return {
    ...(config.browserbaseApiKey != null && { browserbaseApiKey: config.browserbaseApiKey }),
    ...(config.browserbaseProjectId != null && { browserbaseProjectId: config.browserbaseProjectId }),
    ...(config.modelApiKey != null && { modelApiKey: config.modelApiKey }),
    ...(config.modelName != null && { modelName: config.modelName }),
  };
}

/**
 * BrowserUse client for Convex.
 * Pass an empty config {} when using Convex Dashboard env vars (recommended).
 *
 * @example With Convex env (recommended – set BROWSERBASE_*, MODEL_API_KEY in Dashboard)
 * const browserUse = new BrowserUse(components.browserUse, {});
 *
 * @example With explicit keys (e.g. from another backend)
 * const browserUse = new BrowserUse(components.browserUse, {
 *   browserbaseApiKey: process.env.BROWSERBASE_API_KEY,
 *   browserbaseProjectId: process.env.BROWSERBASE_PROJECT_ID,
 *   modelApiKey: process.env.MODEL_API_KEY,
 * });
 */
export class BrowserUse {
  private component: BrowserUseComponentApi;
  private config: BrowserUseConfig;

  constructor(component: BrowserUseComponentApi, config: BrowserUseConfig = {}) {
    this.component = component;
    this.config = config;
  }

  /**
   * Start a new browser session
   */
  async startSession(
    ctx: ActionCtx,
    args: {
      url?: string;
      browserbaseSessionId?: string;
      options?: StartSessionOptions;
    }
  ): Promise<SessionInfo> {
    return await ctx.runAction(this.component.lib.startSession, {
      ...args,
      ...apiKeyArgs(this.config),
    });
  }

  /**
   * End a browser session
   */
  async endSession(
    ctx: ActionCtx,
    args: { sessionId: string }
  ): Promise<{ success: boolean }> {
    return await ctx.runAction(this.component.lib.endSession, {
      ...args,
      ...apiKeyArgs(this.config),
    });
  }

  /**
   * Extract structured data from a page using AI
   */
  async extract<T extends z.ZodTypeAny>(
    ctx: ActionCtx,
    args: {
      sessionId?: string;
      url?: string;
      instruction: string;
      schema: T;
      options?: { timeout?: number; waitUntil?: string };
    }
  ): Promise<z.infer<T>> {
    return await ctx.runAction(this.component.lib.extract, {
      ...args,
      schema: zodToJsonSchema(args.schema),
      ...apiKeyArgs(this.config),
    });
  }

  /**
   * Perform a browser action using natural language
   */
  async act(
    ctx: ActionCtx,
    args: {
      sessionId?: string;
      url?: string;
      action: string;
      options?: { timeout?: number; waitUntil?: string };
    }
  ): Promise<ActionResult> {
    return await ctx.runAction(this.component.lib.act, {
      ...args,
      ...apiKeyArgs(this.config),
    });
  }

  /**
   * Observe available actions on a page
   */
  async observe(
    ctx: ActionCtx,
    args: {
      sessionId?: string;
      url?: string;
      instruction?: string;
      options?: { timeout?: number; waitUntil?: string };
    }
  ): Promise<ObservableElement[]> {
    return await ctx.runAction(this.component.lib.observe, {
      ...args,
      ...apiKeyArgs(this.config),
    });
  }

  /**
   * Run an autonomous agent to complete a multi-step task
   */
  async agent(
    ctx: ActionCtx,
    args: {
      sessionId?: string;
      url?: string;
      instruction: string;
      options?: {
        maxSteps?: number;
        timeout?: number;
        waitUntil?: string;
        systemPrompt?: string;
      };
    }
  ): Promise<AgentResult> {
    return await ctx.runAction(this.component.lib.agent, {
      ...args,
      ...apiKeyArgs(this.config),
    });
  }
}

/**
 * Convert a Zod schema to JSON Schema
 * (Simplified version - in production, use zod-to-json-schema)
 */
function zodToJsonSchema(schema: z.ZodTypeAny): Record<string, any> {
  // This is a simplified converter
  // In production, use the zod-to-json-schema package
  const def = (schema as any)._def;
  
  if (def.typeName === "ZodObject") {
    const properties: Record<string, any> = {};
    const required: string[] = [];
    
    for (const [key, value] of Object.entries(def.shape())) {
      properties[key] = zodToJsonSchema(value as z.ZodTypeAny);
      if (!((value as any)._def.typeName === "ZodOptional")) {
        required.push(key);
      }
    }
    
    return { type: "object", properties, required };
  }
  
  if (def.typeName === "ZodArray") {
    return { type: "array", items: zodToJsonSchema(def.type) };
  }
  
  if (def.typeName === "ZodString") {
    return { type: "string" };
  }
  
  if (def.typeName === "ZodNumber") {
    return { type: "number" };
  }
  
  if (def.typeName === "ZodBoolean") {
    return { type: "boolean" };
  }
  
  if (def.typeName === "ZodOptional") {
    return zodToJsonSchema(def.innerType);
  }
  
  return { type: "any" };
}

export default BrowserUse;
